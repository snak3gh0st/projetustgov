---
phase: 02-operational-maturity
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - "config.yaml"
  - "src/config/__init__.py"
  - "src/config/loader.py"
autonomous: true
must_haves:
  truths:
    - "Configuration loads from YAML with environment variable substitution"
    - "Pydantic validates all config values"
    - "Config is accessible via get_config() function"
  artifacts:
    - path: "config.yaml"
      provides: "External configuration with alerting, reconciliation, extraction, lineage sections"
    - path: "src/config/loader.py"
      provides: "Config loading with Pydantic validation"
    - exports:
        - "get_config()"
        - "AppConfig"
  key_links:
    - from: "src/config/loader.py"
      to: "config.yaml"
      via: "yaml.safe_load with env substitution"
    - from: "src/monitor/alerts.py"
      to: "src/config/loader.py"
      via: "get_config().alerting"
---

<objective>
Create externalized YAML configuration with Pydantic validation.

**Purpose:** Replace hardcoded settings with external config file. Enables changing behavior without code changes.

**Output:** Working config.yaml and config loader module.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/PROJECT.md
@.planning/research/02-RESEARCH.md

# Phase 2 requires:
- alerting.telegram (already has MON-01, MON-02, MON-05, MON-07 from Phase 1)
- alerting.email (MON-03 - NEW)
- reconciliation (MON-04 - NEW)
- extraction settings
- lineage settings

# From Phase 1:
- settings.py already exists with DATABASE_URL, extraction_hour
- TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID already in .env
</context>

<tasks>

<task type="auto">
  <name>Create config.yaml with all Phase 2 settings</name>
  <files>config.yaml</files>
  <action>
    Create config.yaml with the following structure:

    ```yaml
    # PROJETUS Configuration
    # Phase 2: Operational Maturity

    # Alerting Configuration
    alerting:
      telegram:
        enabled: true
        bot_token: "${TELEGRAM_BOT_TOKEN}"
        chat_id: "${TELEGRAM_CHAT_ID}"
      email:
        enabled: false  # Enable after SMTP configured
        smtp_host: "${EMAIL_SMTP_HOST}"
        smtp_port: 587
        from: alerts@projetus.com
        to:
          - tito@projetus.com
          - philipe@projetus.com

    # Reconciliation Configuration
    reconciliation:
      volume_tolerance_percent: 10
      alert_on_mismatch: true
      alert_on_scheduler_miss: true

    # Extraction Configuration
    extraction:
      hour: 9
      timezone: America/Sao_Paulo
      dry_run_default: false

    # Data Lineage Configuration
    lineage:
      enabled: true
      track_pipeline_version: true

    # Database (references DATABASE_URL from .env)
    database:
      url: "${DATABASE_URL}"
    ```

    Do NOT create actual env vars - leave as ${VAR_NAME} placeholders.
  </action>
  <verify>`python -c "import yaml; yaml.safe_load(open('config.yaml')); print('config.yaml valid')"`</verify>
  <done>config.yaml exists with alerting, reconciliation, extraction, lineage sections</done>
</task>

<task type="auto">
  <name>Create src/config directory and __init__.py</name>
  <files>src/config/__init__.py</files>
  <action>
    Create src/config/__init__.py that exports:

    ```python
    """Configuration module for PROJETUS."""
    from src.config.loader import get_config, AppConfig

    __all__ = ["get_config", "AppConfig"]
    ```
  </action>
  <verify>`python -c "from src.config import get_config, AppConfig; print('config module imports')"`</verify>
  <done>src/config/__init__.py exports get_config and AppConfig</done>
</task>

<task type="auto">
  <name>Create src/config/loader.py with Pydantic models</name>
  <files>src/config/loader.py</files>
  <action>
    Create src/config/loader.py with:

    1. Pydantic BaseModel classes for each config section:
       - TelegramConfig (enabled: bool, bot_token: str, chat_id: str)
       - EmailConfig (enabled: bool, smtp_host: str, smtp_port: int, from: EmailStr, to: list[EmailStr])
       - AlertingConfig (telegram: TelegramConfig, email: EmailConfig)
       - ReconciliationConfig (volume_tolerance_percent: int, alert_on_mismatch: bool, alert_on_scheduler_miss: bool)
       - ExtractionConfig (hour: int, timezone: str, dry_run_default: bool)
       - LineageConfig (enabled: bool, track_pipeline_version: bool)
       - DatabaseConfig (url: str)
       - AppConfig (all sections)

    2. Environment variable substitution function:
       - replace ${VAR_NAME} with os.getenv('VAR_NAME')
       - Handle nested dicts and lists recursively

    3. get_config() function:
       - Load config.yaml with yaml.safe_load
       - Apply env substitution
       - Validate with Pydantic
       - Cache result with @lru_cache

    Reference patterns from 02-RESEARCH.md in .planning directory.
  </action>
  <verify>`python -c "from src.config.loader import get_config; c = get_config(); print(f'alerting.telegram.enabled: {c.alerting.telegram.enabled}')"`</verify>
  <done>get_config() returns validated AppConfig with all sections accessible</done>
</task>

</tasks>

<verification>
- [ ] `python -c "from src.config import get_config; c = get_config(); print('Config loaded:', c.alerting.telegram.enabled)"`
- [ ] Config sections accessible: alerting, reconciliation, extraction, lineage, database
- [ ] Email addresses validated by Pydantic
- [ ] Environment variables substituted correctly
</verification>

<success_criteria>
Configuration system works:
- config.yaml loads without errors
- Pydantic validates all values
- get_config() returns typed config object
- Alerting, reconciliation, extraction, lineage sections all present
</success_criteria>

<output>
After completion, create `.planning/phases/02-operational-maturity/02-01-SUMMARY.md`
</output>
